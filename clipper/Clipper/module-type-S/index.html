<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (clipper.Clipper.S)</title><link rel="stylesheet" href="../../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">clipper</a> &#x00BB; <a href="../index.html">Clipper</a> &#x00BB; S</nav><header class="odoc-preamble"><h1>Module type <code><span>Clipper.S</span></code></h1><p>The signature of Clipper2 binding modules produced by the provided <code>Make</code> functors</p></header><nav class="odoc-toc"><ul><li><a href="#construction-/-conversion_2">Construction / Conversion</a></li><li><a href="#access">Access</a></li><li><a href="#boolean-operations">Boolean Operations</a></li><li><a href="#offsetting">Offsetting</a></li><li><a href="#minkowski">Minkowski</a></li><li><a href="#path-simplification">Path Simplification</a></li><li><a href="#transformation_2">Transformation</a></li><li><a href="#geometry_2">Geometry</a></li><li><a href="#export">Export</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-n"><a href="#type-n" class="anchor"></a><code><span><span class="keyword">type</span> n</span></code></div><div class="spec-doc"><p>numeric type matching the elements of <a href="#type-v"><code>v</code></a></p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-v"><a href="#type-v" class="anchor"></a><code><span><span class="keyword">type</span> v</span></code></div><div class="spec-doc"><p>2d vector type representing points</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-contour"><a href="#type-contour" class="anchor"></a><code><span><span class="keyword">type</span> contour</span></code></div><div class="spec-doc"><p>contour -- path/sequence of points</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-poly"><a href="#type-poly" class="anchor"></a><code><span><span class="keyword">type</span> poly</span></code></div><div class="spec-doc"><p>polygon type -- outer path and zero or more inner paths (holes)</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-clip_type"><a href="#type-clip_type" class="anchor"></a><code><span><span class="keyword">type</span> clip_type</span><span> = </span><span>[ </span></code><ol><li id="type-clip_type.None" class="def constructor anchored"><a href="#type-clip_type.None" class="anchor"></a><code><span>| </span></code><code><span>`None</span></code></li><li id="type-clip_type.Intersection" class="def constructor anchored"><a href="#type-clip_type.Intersection" class="anchor"></a><code><span>| </span></code><code><span>`Intersection</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>AND -- regions covered by both subject and clip polygons</p><span class="comment-delim">*)</span></div></li><li id="type-clip_type.Union" class="def constructor anchored"><a href="#type-clip_type.Union" class="anchor"></a><code><span>| </span></code><code><span>`Union</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>OR -- regions covered by subject or clip polygons, or both polygons</p><span class="comment-delim">*)</span></div></li><li id="type-clip_type.Difference" class="def constructor anchored"><a href="#type-clip_type.Difference" class="anchor"></a><code><span>| </span></code><code><span>`Difference</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>NOT -- regions covered by subject, but not clip polygons</p><span class="comment-delim">*)</span></div></li><li id="type-clip_type.Xor" class="def constructor anchored"><a href="#type-clip_type.Xor" class="anchor"></a><code><span>| </span></code><code><span>`Xor</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>exclusive or -- regions covered by subject or clip polygons, but not both</p><span class="comment-delim">*)</span></div></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>Clipping types for boolean operations. See Clipper2's docs for <a href="http://www.angusj.com/clipper2/Docs/Units/Clipper/Types/ClipType.htm">visual demonstrations</a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-fill_rule"><a href="#type-fill_rule" class="anchor"></a><code><span><span class="keyword">type</span> fill_rule</span><span> = </span><span>[ </span></code><ol><li id="type-fill_rule.EvenOdd" class="def constructor anchored"><a href="#type-fill_rule.EvenOdd" class="anchor"></a><code><span>| </span></code><code><span>`EvenOdd</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>only odd numbered sub-regions are filled</p><span class="comment-delim">*)</span></div></li><li id="type-fill_rule.NonZero" class="def constructor anchored"><a href="#type-fill_rule.NonZero" class="anchor"></a><code><span>| </span></code><code><span>`NonZero</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>non-zero sub-regions are filled</p><span class="comment-delim">*)</span></div></li><li id="type-fill_rule.Positive" class="def constructor anchored"><a href="#type-fill_rule.Positive" class="anchor"></a><code><span>| </span></code><code><span>`Positive</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>only sub-regions with winding counts <code>&gt; 0</code> are filled</p><span class="comment-delim">*)</span></div></li><li id="type-fill_rule.Negative" class="def constructor anchored"><a href="#type-fill_rule.Negative" class="anchor"></a><code><span>| </span></code><code><span>`Negative</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>only sub-regions with winding counts <code>&lt; 0</code> are filled</p><span class="comment-delim">*)</span></div></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>Filling rules used by the clipping algorithm for boolean operations. See Clipper2's docs for a detailed <a href="http://www.angusj.com/clipper2/Docs/Units/Clipper/Types/FillRule.htm">explanation</a> of how they differ).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-join_type"><a href="#type-join_type" class="anchor"></a><code><span><span class="keyword">type</span> join_type</span><span> = </span><span>[ </span></code><ol><li id="type-join_type.Square" class="def constructor anchored"><a href="#type-join_type.Square" class="anchor"></a><code><span>| </span></code><code><span>`Square</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>squaring applied uniformally at all joins where the <i>internal</i> join angle is less than 90 degrees. The squared edg will be at exactly the offset distance from the join vertex</p><span class="comment-delim">*)</span></div></li><li id="type-join_type.Round" class="def constructor anchored"><a href="#type-join_type.Round" class="anchor"></a><code><span>| </span></code><code><span>`Round</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>rounding is appliedto all joins that have convex external angles, and it maintains the exact offset distance from the join vertex</p><span class="comment-delim">*)</span></div></li><li id="type-join_type.Miter" class="def constructor anchored"><a href="#type-join_type.Miter" class="anchor"></a><code><span>| </span></code><code><span>`Miter</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>there's a necessary limit to mitered joins (to avoid narrow angled joins producing excessively long and narrow <a href="http://www.angusj.com/clipper2/Docs/Units/Clipper.Offset/Classes/ClipperOffset/Properties/MiterLimit.htm">spikes</a>)). The limit sets the maximum distance in multiples of the <code>delta</code> specified for the offsetting operation (default is <code>2.</code>, which is the minimum allowed).</p><span class="comment-delim">*)</span></div></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>Defines the treatment of corners when offsetting paths. Visual examples are available in the Clipper2 <a href="http://www.angusj.com/clipper2/Docs/Units/Clipper/Types/JoinType.htm">docs</a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-end_type"><a href="#type-end_type" class="anchor"></a><code><span><span class="keyword">type</span> end_type</span><span> = </span><span>[ </span></code><ol><li id="type-end_type.Polygon" class="def constructor anchored"><a href="#type-end_type.Polygon" class="anchor"></a><code><span>| </span></code><code><span>`Polygon</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>paths are assumed to be closed and treated as polygons</p><span class="comment-delim">*)</span></div></li><li id="type-end_type.Joined" class="def constructor anchored"><a href="#type-end_type.Joined" class="anchor"></a><code><span>| </span></code><code><span>`Joined</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>ends are joined and the paths are treated as polylines</p><span class="comment-delim">*)</span></div></li><li id="type-end_type.Butt" class="def constructor anchored"><a href="#type-end_type.Butt" class="anchor"></a><code><span>| </span></code><code><span>`Butt</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>ends are squared off without any extrusion</p><span class="comment-delim">*)</span></div></li><li id="type-end_type.Square" class="def constructor anchored"><a href="#type-end_type.Square" class="anchor"></a><code><span>| </span></code><code><span>`Square</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>ends extend the offset amount while being <i>squared off</i></p><span class="comment-delim">*)</span></div></li><li id="type-end_type.Round" class="def constructor anchored"><a href="#type-end_type.Round" class="anchor"></a><code><span>| </span></code><code><span>`Round</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>ends extend the offset amount while being <i>rounded off</i></p><span class="comment-delim">*)</span></div></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>Sets whether paths are treated as closed (<code>`Polygon</code>) when offsetting or open (and how to do so, if so). Visual examples are available in the Clipper2 <a href="http://www.angusj.com/clipper2/Docs/Units/Clipper/Types/EndType.htm">docs</a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>('cpp, 'ctr) t</span></span></code></div><div class="spec-doc"><p>Clipper2 paths and polygons</p><p>This GADT abstracts over the Clipper2 Path and Paths types in order to avoid splitting the interface into two largely duplicated modules. The <code>'ctr</code> parameter specifies the corresponding OCaml type from which it can be constructed from, or destructed to.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-path"><a href="#type-path" class="anchor"></a><code><span><span class="keyword">type</span> path</span><span> = <span><span>(<span>[ `Path ]</span>, <a href="#type-contour">contour</a>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The Clipper2 path type (std::vector of point)</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-paths"><a href="#type-paths" class="anchor"></a><code><span><span class="keyword">type</span> paths</span><span> = <span><span>(<span>[ `Paths ]</span>, <span><a href="#type-contour">contour</a> list</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The Clipper2 paths type (std::vector of path)</p><p>These lists of contours are not organized hierarchically (by parent-child / outer-hole) relationships, and may include any number of open paths or polygons.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Rect"><a href="#module-Rect" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Rect/index.html">Rect</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An axis-aligned rectangle used bounding box computations and quick rectangular clipping (boolean intersection) operations. (see <a href="#val-rect_clip"><code>rect_clip</code></a>)</p></div></div><h2 id="construction-/-conversion_2"><a href="#construction-/-conversion_2" class="anchor"></a>Construction / Conversion</h2><div class="odoc-spec"><div class="spec value anchored" id="val-path"><a href="#val-path" class="anchor"></a><code><span><span class="keyword">val</span> path : <span><a href="#type-contour">contour</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-path">path</a></span></code></div><div class="spec-doc"><p><code>path ps</code></p><p>Create a path from the list of 2d points <code>ps</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-paths"><a href="#val-paths" class="anchor"></a><code><span><span class="keyword">val</span> paths : <span><span><a href="#type-contour">contour</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-paths">paths</a></span></code></div><div class="spec-doc"><p><code>paths ps</code></p><p>Create paths from the list of lists of 2d points <code>ps</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-contour"><a href="#val-contour" class="anchor"></a><code><span><span class="keyword">val</span> contour : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">'contour</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'contour</span></span></code></div><div class="spec-doc"><p><code>contour t</code></p><p>Convert the path (or paths) <code>t</code> to contour(s) of 2d points.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_poly"><a href="#val-of_poly" class="anchor"></a><code><span><span class="keyword">val</span> of_poly : <span><a href="#type-poly">poly</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-paths">paths</a></span></code></div><div class="spec-doc"><p><code>of_poly p</code></p><p>Create a paths from a polygon <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_polys"><a href="#val-of_polys" class="anchor"></a><code><span><span class="keyword">val</span> of_polys : <span><span><a href="#type-poly">poly</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-paths">paths</a></span></code></div><div class="spec-doc"><p><code>of_polys ps</code></p><p>Create a paths from a list of polygons <code>ps</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_poly"><a href="#val-to_poly" class="anchor"></a><code><span><span class="keyword">val</span> to_poly : <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-poly">poly</a></span></code></div><div class="spec-doc"><p><code>to_poly t</code></p><p>Create a polygon with the outline <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_polys"><a href="#val-to_polys" class="anchor"></a><code><span><span class="keyword">val</span> to_polys : <span>?fill_rule:<a href="#type-fill_rule">fill_rule</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-poly">poly</a> list</span></span></code></div><div class="spec-doc"><p><code>to_polys ?fill_rule t</code></p><p>Extract a list of non-overlapping polygons from the set of paths <code>t</code>. This involves a clipper union operation tracking the parent-child (outline-hole) relationships of the paths, thus <code>fill_rule</code> can be provided to override the default rule if desired.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ellipse"><a href="#val-ellipse" class="anchor"></a><code><span><span class="keyword">val</span> ellipse : <span>?fn:int <span class="arrow">&#45;&gt;</span></span> <span>?centre:<a href="#type-v">v</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-v">v</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-path">path</a></span></code></div><div class="spec-doc"><p><code>ellipse ?fn ?centre rs</code></p><p>Draw an elliptical path with with the specified xy radii <code>rs</code> centred on the origin, or at the point <code>centre</code> if provided. The number of segments can be set explicitly with <code>fn</code>, otherwise the quality is calculated based on the dimensions.</p></div></div><h2 id="access"><a href="#access" class="anchor"></a>Access</h2><div class="odoc-spec"><div class="spec value anchored" id="val-n_pts"><a href="#val-n_pts" class="anchor"></a><code><span><span class="keyword">val</span> n_pts : <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>n_pts t</code></p><p>Return the number of points in the path(s) <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-n_pts_sub"><a href="#val-n_pts_sub" class="anchor"></a><code><span><span class="keyword">val</span> n_pts_sub : <span><a href="#type-paths">paths</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>n_pts_sub t i</code></p><p>Return the number of points in the <code>i</code>th sub-path of <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-n_paths"><a href="#val-n_paths" class="anchor"></a><code><span><span class="keyword">val</span> n_paths : <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>n_paths t</code></p><p>Return the number of paths in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-subpath"><a href="#val-subpath" class="anchor"></a><code><span><span class="keyword">val</span> subpath : <span><a href="#type-paths">paths</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-path">path</a></span></code></div><div class="spec-doc"><p><code>subpath t i</code></p><p>Get the <code>i</code>th subpath from the paths <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-path_pt"><a href="#val-path_pt" class="anchor"></a><code><span><span class="keyword">val</span> path_pt : <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-v">v</a></span></code></div><div class="spec-doc"><p><code>path_pt t i</code></p><p>Get the point at index <code>i</code> from the path <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-paths_pt"><a href="#val-paths_pt" class="anchor"></a><code><span><span class="keyword">val</span> paths_pt : <span><a href="#type-paths">paths</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-v">v</a></span></code></div><div class="spec-doc"><p><code>paths_pt t i</code></p><p>Get the point at index <code>j</code> from the path at index <code>i</code> of <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(.%())"><a href="#val-(.%())" class="anchor"></a><code><span><span class="keyword">val</span> (.%()) : <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-v">v</a></span></code></div><div class="spec-doc"><p><code>path.%(i)</code> gets the point at index <code>i</code> from <code>path</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(.%{})"><a href="#val-(.%{})" class="anchor"></a><code><span><span class="keyword">val</span> (.%{}) : <span><a href="#type-paths">paths</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * int)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-v">v</a></span></code></div><div class="spec-doc"><p><code>paths.%(i, j)</code> gets the point at index <code>j</code> from the <code>i</code>th path in <code>paths</code>.</p></div></div><h2 id="boolean-operations"><a href="#boolean-operations" class="anchor"></a>Boolean Operations</h2><div class="odoc-spec"><div class="spec value anchored" id="val-boolean_op"><a href="#val-boolean_op" class="anchor"></a><code><span><span class="keyword">val</span> boolean_op : 
  <span>?fill_rule:<a href="#type-fill_rule">fill_rule</a> <span class="arrow">&#45;&gt;</span></span>
  <span>op:<a href="#type-clip_type">clip_type</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-paths">paths</a></span></code></div><div class="spec-doc"><p><code>boolean_op ?fill_rule ~op subjects clips</code></p><p>Perform the boolean operation <code>op</code> with the specified <code>fill_rule</code> on the polygons (closed paths) <code>subjects</code> and list of clipping polygons <code>clips</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-intersect"><a href="#val-intersect" class="anchor"></a><code><span><span class="keyword">val</span> intersect : <span>?fill_rule:<a href="#type-fill_rule">fill_rule</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-paths">paths</a></span></code></div><div class="spec-doc"><p><code>intersect ?fill_rule ts</code></p><p>Intersect the list of polygons <code>ts</code> according to <code>fill_rule</code>. The result includes regions covered by all polygons.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-union"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span>?fill_rule:<a href="#type-fill_rule">fill_rule</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-paths">paths</a></span></code></div><div class="spec-doc"><p><code>union ?fill_rule subjects</code></p><p>Union the polygons <code>subjects</code> according to <code>fill_rule</code>. The result includes the regions covered by any of the polygons contained in <code>subjects</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span>?fill_rule:<a href="#type-fill_rule">fill_rule</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-paths">paths</a></span></code></div><div class="spec-doc"><p><code>add ?fill_rule a b</code></p><p><a href="#val-union"><code>union</code></a> the polygon <code>a</code> and <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-difference"><a href="#val-difference" class="anchor"></a><code><span><span class="keyword">val</span> difference : 
  <span>?fill_rule:<a href="#type-fill_rule">fill_rule</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-paths">paths</a></span></code></div><div class="spec-doc"><p><code>difference ?fill_rule subjects clips</code></p><p>Difference the polygons <code>clips</code> from the polygon <code>subjects</code> according to <code>fill_rule</code>. The result includes the regions covered by the polygon <code>subjects</code>, but not <code>clips</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span>?fill_rule:<a href="#type-fill_rule">fill_rule</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-paths">paths</a></span></code></div><div class="spec-doc"><p><code>sub a b</code></p><p>Difference the polygon <code>b</code> from <code>a</code> (alias to <a href="#val-difference"><code>difference</code></a>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xor"><a href="#val-xor" class="anchor"></a><code><span><span class="keyword">val</span> xor : <span>?fill_rule:<a href="#type-fill_rule">fill_rule</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-paths">paths</a></span></code></div><div class="spec-doc"><p><code>xor ?fill_rule ts</code></p><p>Perform the exclusive-or boolean operation between the closed ps <code>a</code> and <code>b</code> according to <code>fill_rule</code>. The result includes regions covered by the either <code>a</code> or <code>b</code>, but not both.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rect_clip"><a href="#val-rect_clip" class="anchor"></a><code><span><span class="keyword">val</span> rect_clip : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="Rect/index.html#type-t">Rect.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-paths">paths</a></span></code></div><div class="spec-doc"><p><code>rect_clip ?closed r t</code></p><p>Intersect the path <code>t</code> with the axis-aligned rectangle <code>r</code>. The path is treated as closed/polygonal by default, but an open path may be clipped by setting <code>~closed:false</code>.</p></div></div><h2 id="offsetting"><a href="#offsetting" class="anchor"></a>Offsetting</h2><div class="odoc-spec"><div class="spec value anchored" id="val-inflate"><a href="#val-inflate" class="anchor"></a><code><span><span class="keyword">val</span> inflate : 
  <span>?miter_limit:float <span class="arrow">&#45;&gt;</span></span>
  <span>?join_type:<a href="#type-join_type">join_type</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?end_type:<a href="#type-end_type">end_type</a> <span class="arrow">&#45;&gt;</span></span>
  <span>delta:float <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-paths">paths</a></span></code></div><div class="spec-doc"><p><code>inflate ?miter_limit ?join_type ?end_type ~delta t</code></p><p>Offset the polygon (or open path) <code>t</code> by <code>delta</code>. If <code>t</code> is a closed polygonal path, it's important that <code>end_type</code> is <code>`Polygon</code> (default if not overridden by user's <code>Config</code>). If instead you select one of the open path end types (e.g. <code>`Joined</code>), the polygon's <i>outline</i> will be inflated (<a href="https://github.com/AngusJohnson/Clipper2/discussions/154#discussion-4284428">example</a>).</p><ul><li>The <code>miter_limit</code> sets the maximum distance in multiples of <code>delta</code> that vertices can be offset from their original positions with <a href="#type-join_type"><code>join_type</code></a> <code>`Miter</code> before squaring is applied (default is <code>2.</code>, which is the minimum allowed -- <code>Invalid_argument</code> is raised otherwise). See the <a href="http://www.angusj.com/clipper2/Docs/Units/Clipper.Offset/Classes/ClipperOffset/Properties/MiterLimit.htm">Clipper2 MiterLimit</a>) page for a visual example.</li><li>with closed paths (polygons), a positive delta specifies how much outer polygon contours will expand and how much inner &quot;hole&quot; contours will contract (and the converse with negative deltas).</li><li>with open paths (polylines), including <code>`Joined</code>, delta specifies the width of the inflated line.</li><li><b>Caution:</b> offsetting self-intersecting polygons may produce unexpected results.</li></ul></div></div><h2 id="minkowski"><a href="#minkowski" class="anchor"></a>Minkowski</h2><div class="odoc-spec"><div class="spec value anchored" id="val-minkowski_sum"><a href="#val-minkowski_sum" class="anchor"></a><code><span><span class="keyword">val</span> minkowski_sum : 
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?fill_rule:<a href="#type-fill_rule">fill_rule</a> <span class="arrow">&#45;&gt;</span></span>
  <span>pattern:<a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-paths">paths</a></span></code></div><div class="spec-doc"><p><code>minkowski_sum ?closed ~pattern t</code></p><p>Apply <a href="https://en.wikipedia.org/wiki/Minkowski_addition">Minkowski addition</a> of the path <code>pattern</code> to the path(s) <code>t</code>. <code>t</code> is treated as a <code>closed</code> polygon(s) unless otherwise specified.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minkowski_diff"><a href="#val-minkowski_diff" class="anchor"></a><code><span><span class="keyword">val</span> minkowski_diff : 
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?fill_rule:<a href="#type-fill_rule">fill_rule</a> <span class="arrow">&#45;&gt;</span></span>
  <span>pattern:<a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-paths">paths</a></span></code></div><div class="spec-doc"><p><code>minkowski_diff ?closed ~pattern t</code></p><p>Apply <a href="https://en.wikipedia.org/wiki/Minkowski_addition">Minkowski subtraction</a> of the path <code>pattern</code> from the path(s) <code>t</code>. <code>t</code> is treated as a <code>closed</code> polygon(s) unless otherwise specified.</p></div></div><h2 id="path-simplification"><a href="#path-simplification" class="anchor"></a>Path Simplification</h2><div class="odoc-spec"><div class="spec value anchored" id="val-simplify"><a href="#val-simplify" class="anchor"></a><code><span><span class="keyword">val</span> simplify : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>simplify ?closed ?eps t</code></p><p>Remove extraneous vertices from the path <code>t</code> (similar to <a href="#val-ramer_douglas_peucker"><code>ramer_douglas_peucker</code></a>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ramer_douglas_peucker"><a href="#val-ramer_douglas_peucker" class="anchor"></a><code><span><span class="keyword">val</span> ramer_douglas_peucker : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>ramer_douglas_peucker ?eps t</code></p><p>Applies the <a href="https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm">Ramer-Douglas-Peucker algorithm</a> to remove extraneous vertices from the path <code>t</code>. Put simply, vertices will be removed if they are less than <code>eps</code> distance from imaginary lines passing through their adjacent vertices.</p><p>This function is particularly useful following offsetting (ie inflating/shrinking paths). Offsetting often creates tiny segments that don't improve path quality. Further these tiny segments create angles that are strongly influenced by integer rounding. While these tiny segments are too small to be noticeable following a single offset procedure, they're likely to degrade the quality of subsequent offsets. And they'll also degrade performance. Because of this, it is strongly recommended calling this function after every polygon offset.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trim_collinear"><a href="#val-trim_collinear" class="anchor"></a><code><span><span class="keyword">val</span> trim_collinear : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>trim_collinear ?closed t</code></p><p>Remove collinear points (that fall on a line drawn between their neighbours) from the path <code>t</code>. The path is treated as <code>closed</code> by default.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-strip_near_equal"><a href="#val-strip_near_equal" class="anchor"></a><code><span><span class="keyword">val</span> strip_near_equal : 
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?eps:float <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>strip_near_equal ?closed ?eps t</code></p><p>Remove adjacent points that are less than <code>eps</code> distance apart from their neighbour from the paths <code>t</code>. The path is treated as <code>closed</code> by default.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-strip_duplicates"><a href="#val-strip_duplicates" class="anchor"></a><code><span><span class="keyword">val</span> strip_duplicates : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>strip_duplicates ?closed ?eps t</code></p><p>Remove adjacent points that duplicate of their neighbours from the paths <code>t</code>. The path is treated as <code>closed</code> by default.</p></div></div><h2 id="transformation_2"><a href="#transformation_2" class="anchor"></a>Transformation</h2><div class="odoc-spec"><div class="spec value anchored" id="val-translate"><a href="#val-translate" class="anchor"></a><code><span><span class="keyword">val</span> translate : <span><a href="#type-v">v</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>translate v t</code></p><p>Translate the path <code>t</code> along the vector <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><a href="#type-v">v</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-v">v</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f t</code></p><p>Map over the points in <code>t</code> with the function <code>f</code>.</p></div></div><h2 id="geometry_2"><a href="#geometry_2" class="anchor"></a>Geometry</h2><div class="odoc-spec"><div class="spec value anchored" id="val-area"><a href="#val-area" class="anchor"></a><code><span><span class="keyword">val</span> area : <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>area t</code></p><p>Compute the signed area of the path <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bounds"><a href="#val-bounds" class="anchor"></a><code><span><span class="keyword">val</span> bounds : <span><span><span>(<span class="type-var">'cpp</span>, <span class="type-var">'ctr</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="Rect/index.html#type-t">Rect.t</a></span></code></div><div class="spec-doc"><p><code>bounds t</code></p><p>Compute the axis-aligned bounding box that contains the path <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_positive"><a href="#val-is_positive" class="anchor"></a><code><span><span class="keyword">val</span> is_positive : <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_positive t</code></p><p>Check if the orientation/winding of the path <code>t</code> is positive.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-point_inside"><a href="#val-point_inside" class="anchor"></a><code><span><span class="keyword">val</span> point_inside : <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-v">v</a> <span class="arrow">&#45;&gt;</span></span> <span>[&gt; `Inside <span>| `OnBorder</span> <span>| `Outside</span> ]</span></span></code></div><div class="spec-doc"><p><code>point_inside t p</code></p><p>Determine whether the point <code>p</code> is inside, outside, or on the border of <code>t</code>.</p></div></div><h2 id="export"><a href="#export" class="anchor"></a>Export</h2><div class="odoc-spec"><div class="spec module anchored" id="module-Svg"><a href="#module-Svg" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Svg/index.html">Svg</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Utilities for writing (and reading) simple SVGs, for use in debugging and quick visualization.</p></div></div></div></body></html>